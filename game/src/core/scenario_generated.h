// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENARIO_MENGDE_SAVE_H_
#define FLATBUFFERS_GENERATED_SCENARIO_MENGDE_SAVE_H_

#include "flatbuffers/flatbuffers.h"

namespace mengde {
namespace save {

struct Scenario;

struct ResourceManagers;

struct TerrainRecord;

struct Terrain;

struct HeroTemplate;

struct HeroClass;

struct BaseIncr;

struct PromotionInfo;

struct Attribute;

struct Position;

struct Equipment;

struct VolatileAttributes;

struct AttributeModifier;

struct TurnBased;

struct StatMod;

struct EventEffect;

struct GeneralEventEffect;

struct GEERestoreHp;

struct OnCmdEventEffect;

struct OCEEPreemptiveAttack;

struct OCEEEnhanceBasicAttack;

struct Magic;

struct LearnInfo;

struct MagicEffect;

struct MagicEffectHp;

struct MagicEffectAttribute;

struct MagicEffectCondition;

struct Assets;

struct EquipmentWithAmount;

struct Hero;

struct LevelExp;

struct EquipmentSet;

enum class EventEffectImpl : uint8_t {
  NONE = 0,
  GeneralEventEffect = 1,
  OnCmdEventEffect = 2,
  MIN = NONE,
  MAX = OnCmdEventEffect
};

inline const EventEffectImpl (&EnumValuesEventEffectImpl())[3] {
  static const EventEffectImpl values[] = {
    EventEffectImpl::NONE,
    EventEffectImpl::GeneralEventEffect,
    EventEffectImpl::OnCmdEventEffect
  };
  return values;
}

inline const char * const *EnumNamesEventEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "GeneralEventEffect",
    "OnCmdEventEffect",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventEffectImpl(EventEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventEffectImpl()[index];
}

template<typename T> struct EventEffectImplTraits {
  static const EventEffectImpl enum_value = EventEffectImpl::NONE;
};

template<> struct EventEffectImplTraits<GeneralEventEffect> {
  static const EventEffectImpl enum_value = EventEffectImpl::GeneralEventEffect;
};

template<> struct EventEffectImplTraits<OnCmdEventEffect> {
  static const EventEffectImpl enum_value = EventEffectImpl::OnCmdEventEffect;
};

bool VerifyEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, EventEffectImpl type);
bool VerifyEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class GeneralEventEffectImpl : uint8_t {
  NONE = 0,
  GEERestoreHp = 1,
  MIN = NONE,
  MAX = GEERestoreHp
};

inline const GeneralEventEffectImpl (&EnumValuesGeneralEventEffectImpl())[2] {
  static const GeneralEventEffectImpl values[] = {
    GeneralEventEffectImpl::NONE,
    GeneralEventEffectImpl::GEERestoreHp
  };
  return values;
}

inline const char * const *EnumNamesGeneralEventEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "GEERestoreHp",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeneralEventEffectImpl(GeneralEventEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGeneralEventEffectImpl()[index];
}

template<typename T> struct GeneralEventEffectImplTraits {
  static const GeneralEventEffectImpl enum_value = GeneralEventEffectImpl::NONE;
};

template<> struct GeneralEventEffectImplTraits<GEERestoreHp> {
  static const GeneralEventEffectImpl enum_value = GeneralEventEffectImpl::GEERestoreHp;
};

bool VerifyGeneralEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, GeneralEventEffectImpl type);
bool VerifyGeneralEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class OnCmdEventEffectImpl : uint8_t {
  NONE = 0,
  OCEEPreemptiveAttack = 1,
  OCEEEnhanceBasicAttack = 2,
  MIN = NONE,
  MAX = OCEEEnhanceBasicAttack
};

inline const OnCmdEventEffectImpl (&EnumValuesOnCmdEventEffectImpl())[3] {
  static const OnCmdEventEffectImpl values[] = {
    OnCmdEventEffectImpl::NONE,
    OnCmdEventEffectImpl::OCEEPreemptiveAttack,
    OnCmdEventEffectImpl::OCEEEnhanceBasicAttack
  };
  return values;
}

inline const char * const *EnumNamesOnCmdEventEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "OCEEPreemptiveAttack",
    "OCEEEnhanceBasicAttack",
    nullptr
  };
  return names;
}

inline const char *EnumNameOnCmdEventEffectImpl(OnCmdEventEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOnCmdEventEffectImpl()[index];
}

template<typename T> struct OnCmdEventEffectImplTraits {
  static const OnCmdEventEffectImpl enum_value = OnCmdEventEffectImpl::NONE;
};

template<> struct OnCmdEventEffectImplTraits<OCEEPreemptiveAttack> {
  static const OnCmdEventEffectImpl enum_value = OnCmdEventEffectImpl::OCEEPreemptiveAttack;
};

template<> struct OnCmdEventEffectImplTraits<OCEEEnhanceBasicAttack> {
  static const OnCmdEventEffectImpl enum_value = OnCmdEventEffectImpl::OCEEEnhanceBasicAttack;
};

bool VerifyOnCmdEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, OnCmdEventEffectImpl type);
bool VerifyOnCmdEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class MagicEffectImpl : uint8_t {
  NONE = 0,
  MagicEffectHp = 1,
  MagicEffectAttribute = 2,
  MagicEffectCondition = 3,
  MIN = NONE,
  MAX = MagicEffectCondition
};

inline const MagicEffectImpl (&EnumValuesMagicEffectImpl())[4] {
  static const MagicEffectImpl values[] = {
    MagicEffectImpl::NONE,
    MagicEffectImpl::MagicEffectHp,
    MagicEffectImpl::MagicEffectAttribute,
    MagicEffectImpl::MagicEffectCondition
  };
  return values;
}

inline const char * const *EnumNamesMagicEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "MagicEffectHp",
    "MagicEffectAttribute",
    "MagicEffectCondition",
    nullptr
  };
  return names;
}

inline const char *EnumNameMagicEffectImpl(MagicEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMagicEffectImpl()[index];
}

template<typename T> struct MagicEffectImplTraits {
  static const MagicEffectImpl enum_value = MagicEffectImpl::NONE;
};

template<> struct MagicEffectImplTraits<MagicEffectHp> {
  static const MagicEffectImpl enum_value = MagicEffectImpl::MagicEffectHp;
};

template<> struct MagicEffectImplTraits<MagicEffectAttribute> {
  static const MagicEffectImpl enum_value = MagicEffectImpl::MagicEffectAttribute;
};

template<> struct MagicEffectImplTraits<MagicEffectCondition> {
  static const MagicEffectImpl enum_value = MagicEffectImpl::MagicEffectCondition;
};

bool VerifyMagicEffectImpl(flatbuffers::Verifier &verifier, const void *obj, MagicEffectImpl type);
bool VerifyMagicEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BaseIncr FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t base_;
  int32_t incr_;

 public:
  BaseIncr() {
    memset(this, 0, sizeof(BaseIncr));
  }
  BaseIncr(int32_t _base, int32_t _incr)
      : base_(flatbuffers::EndianScalar(_base)),
        incr_(flatbuffers::EndianScalar(_incr)) {
  }
  int32_t base() const {
    return flatbuffers::EndianScalar(base_);
  }
  int32_t incr() const {
    return flatbuffers::EndianScalar(incr_);
  }
};
FLATBUFFERS_STRUCT_END(BaseIncr, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Attribute FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t atk_;
  int32_t def_;
  int32_t dex_;
  int32_t itl_;
  int32_t mor_;

 public:
  Attribute() {
    memset(this, 0, sizeof(Attribute));
  }
  Attribute(int32_t _atk, int32_t _def, int32_t _dex, int32_t _itl, int32_t _mor)
      : atk_(flatbuffers::EndianScalar(_atk)),
        def_(flatbuffers::EndianScalar(_def)),
        dex_(flatbuffers::EndianScalar(_dex)),
        itl_(flatbuffers::EndianScalar(_itl)),
        mor_(flatbuffers::EndianScalar(_mor)) {
  }
  int32_t atk() const {
    return flatbuffers::EndianScalar(atk_);
  }
  int32_t def() const {
    return flatbuffers::EndianScalar(def_);
  }
  int32_t dex() const {
    return flatbuffers::EndianScalar(dex_);
  }
  int32_t itl() const {
    return flatbuffers::EndianScalar(itl_);
  }
  int32_t mor() const {
    return flatbuffers::EndianScalar(mor_);
  }
};
FLATBUFFERS_STRUCT_END(Attribute, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Position() {
    memset(this, 0, sizeof(Position));
  }
  Position(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TurnBased FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t turns_;

 public:
  TurnBased() {
    memset(this, 0, sizeof(TurnBased));
  }
  TurnBased(uint16_t _turns)
      : turns_(flatbuffers::EndianScalar(_turns)) {
  }
  uint16_t turns() const {
    return flatbuffers::EndianScalar(turns_);
  }
};
FLATBUFFERS_STRUCT_END(TurnBased, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) StatMod FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t addend_;
  int16_t multiplier_;

 public:
  StatMod() {
    memset(this, 0, sizeof(StatMod));
  }
  StatMod(int16_t _addend, int16_t _multiplier)
      : addend_(flatbuffers::EndianScalar(_addend)),
        multiplier_(flatbuffers::EndianScalar(_multiplier)) {
  }
  int16_t addend() const {
    return flatbuffers::EndianScalar(addend_);
  }
  int16_t multiplier() const {
    return flatbuffers::EndianScalar(multiplier_);
  }
};
FLATBUFFERS_STRUCT_END(StatMod, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) LearnInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t id_;
  uint16_t lv_;

 public:
  LearnInfo() {
    memset(this, 0, sizeof(LearnInfo));
  }
  LearnInfo(uint16_t _id, uint16_t _lv)
      : id_(flatbuffers::EndianScalar(_id)),
        lv_(flatbuffers::EndianScalar(_lv)) {
  }
  uint16_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  uint16_t lv() const {
    return flatbuffers::EndianScalar(lv_);
  }
};
FLATBUFFERS_STRUCT_END(LearnInfo, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) LevelExp FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t level_;
  uint16_t exp_;

 public:
  LevelExp() {
    memset(this, 0, sizeof(LevelExp));
  }
  LevelExp(uint16_t _level, uint16_t _exp)
      : level_(flatbuffers::EndianScalar(_level)),
        exp_(flatbuffers::EndianScalar(_exp)) {
  }
  uint16_t level() const {
    return flatbuffers::EndianScalar(level_);
  }
  uint16_t exp() const {
    return flatbuffers::EndianScalar(exp_);
  }
};
FLATBUFFERS_STRUCT_END(LevelExp, 4);

struct Scenario FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_STAGE_ID_LIST = 6,
    VT_STAGE_NO = 8,
    VT_RESOURCE_MANAGERS = 10,
    VT_ASSETS = 12
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *stage_id_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STAGE_ID_LIST);
  }
  uint32_t stage_no() const {
    return GetField<uint32_t>(VT_STAGE_NO, 0);
  }
  const ResourceManagers *resource_managers() const {
    return GetPointer<const ResourceManagers *>(VT_RESOURCE_MANAGERS);
  }
  const Assets *assets() const {
    return GetPointer<const Assets *>(VT_ASSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_STAGE_ID_LIST) &&
           verifier.VerifyVector(stage_id_list()) &&
           verifier.VerifyVectorOfStrings(stage_id_list()) &&
           VerifyField<uint32_t>(verifier, VT_STAGE_NO) &&
           VerifyOffset(verifier, VT_RESOURCE_MANAGERS) &&
           verifier.VerifyTable(resource_managers()) &&
           VerifyOffset(verifier, VT_ASSETS) &&
           verifier.VerifyTable(assets()) &&
           verifier.EndTable();
  }
};

struct ScenarioBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Scenario::VT_ID, id);
  }
  void add_stage_id_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> stage_id_list) {
    fbb_.AddOffset(Scenario::VT_STAGE_ID_LIST, stage_id_list);
  }
  void add_stage_no(uint32_t stage_no) {
    fbb_.AddElement<uint32_t>(Scenario::VT_STAGE_NO, stage_no, 0);
  }
  void add_resource_managers(flatbuffers::Offset<ResourceManagers> resource_managers) {
    fbb_.AddOffset(Scenario::VT_RESOURCE_MANAGERS, resource_managers);
  }
  void add_assets(flatbuffers::Offset<Assets> assets) {
    fbb_.AddOffset(Scenario::VT_ASSETS, assets);
  }
  explicit ScenarioBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScenarioBuilder &operator=(const ScenarioBuilder &);
  flatbuffers::Offset<Scenario> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scenario>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scenario> CreateScenario(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> stage_id_list = 0,
    uint32_t stage_no = 0,
    flatbuffers::Offset<ResourceManagers> resource_managers = 0,
    flatbuffers::Offset<Assets> assets = 0) {
  ScenarioBuilder builder_(_fbb);
  builder_.add_assets(assets);
  builder_.add_resource_managers(resource_managers);
  builder_.add_stage_no(stage_no);
  builder_.add_stage_id_list(stage_id_list);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scenario> CreateScenarioDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *stage_id_list = nullptr,
    uint32_t stage_no = 0,
    flatbuffers::Offset<ResourceManagers> resource_managers = 0,
    flatbuffers::Offset<Assets> assets = 0) {
  return mengde::save::CreateScenario(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      stage_id_list ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*stage_id_list) : 0,
      stage_no,
      resource_managers,
      assets);
}

struct ResourceManagers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TERRAIN_MANAGER = 4,
    VT_HERO_CLASS_MANAGER = 6,
    VT_MAGIC_MANAGER = 8,
    VT_EQUIPMENT_MANAGER = 10,
    VT_HERO_TPL_MANAGER = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<Terrain>> *terrain_manager() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Terrain>> *>(VT_TERRAIN_MANAGER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HeroClass>> *hero_class_manager() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeroClass>> *>(VT_HERO_CLASS_MANAGER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Magic>> *magic_manager() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Magic>> *>(VT_MAGIC_MANAGER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Equipment>> *equipment_manager() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Equipment>> *>(VT_EQUIPMENT_MANAGER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>> *hero_tpl_manager() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>> *>(VT_HERO_TPL_MANAGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TERRAIN_MANAGER) &&
           verifier.VerifyVector(terrain_manager()) &&
           verifier.VerifyVectorOfTables(terrain_manager()) &&
           VerifyOffset(verifier, VT_HERO_CLASS_MANAGER) &&
           verifier.VerifyVector(hero_class_manager()) &&
           verifier.VerifyVectorOfTables(hero_class_manager()) &&
           VerifyOffset(verifier, VT_MAGIC_MANAGER) &&
           verifier.VerifyVector(magic_manager()) &&
           verifier.VerifyVectorOfTables(magic_manager()) &&
           VerifyOffset(verifier, VT_EQUIPMENT_MANAGER) &&
           verifier.VerifyVector(equipment_manager()) &&
           verifier.VerifyVectorOfTables(equipment_manager()) &&
           VerifyOffset(verifier, VT_HERO_TPL_MANAGER) &&
           verifier.VerifyVector(hero_tpl_manager()) &&
           verifier.VerifyVectorOfTables(hero_tpl_manager()) &&
           verifier.EndTable();
  }
};

struct ResourceManagersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_terrain_manager(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Terrain>>> terrain_manager) {
    fbb_.AddOffset(ResourceManagers::VT_TERRAIN_MANAGER, terrain_manager);
  }
  void add_hero_class_manager(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroClass>>> hero_class_manager) {
    fbb_.AddOffset(ResourceManagers::VT_HERO_CLASS_MANAGER, hero_class_manager);
  }
  void add_magic_manager(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Magic>>> magic_manager) {
    fbb_.AddOffset(ResourceManagers::VT_MAGIC_MANAGER, magic_manager);
  }
  void add_equipment_manager(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Equipment>>> equipment_manager) {
    fbb_.AddOffset(ResourceManagers::VT_EQUIPMENT_MANAGER, equipment_manager);
  }
  void add_hero_tpl_manager(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>>> hero_tpl_manager) {
    fbb_.AddOffset(ResourceManagers::VT_HERO_TPL_MANAGER, hero_tpl_manager);
  }
  explicit ResourceManagersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceManagersBuilder &operator=(const ResourceManagersBuilder &);
  flatbuffers::Offset<ResourceManagers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourceManagers>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourceManagers> CreateResourceManagers(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Terrain>>> terrain_manager = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroClass>>> hero_class_manager = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Magic>>> magic_manager = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Equipment>>> equipment_manager = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>>> hero_tpl_manager = 0) {
  ResourceManagersBuilder builder_(_fbb);
  builder_.add_hero_tpl_manager(hero_tpl_manager);
  builder_.add_equipment_manager(equipment_manager);
  builder_.add_magic_manager(magic_manager);
  builder_.add_hero_class_manager(hero_class_manager);
  builder_.add_terrain_manager(terrain_manager);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResourceManagers> CreateResourceManagersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Terrain>> *terrain_manager = nullptr,
    const std::vector<flatbuffers::Offset<HeroClass>> *hero_class_manager = nullptr,
    const std::vector<flatbuffers::Offset<Magic>> *magic_manager = nullptr,
    const std::vector<flatbuffers::Offset<Equipment>> *equipment_manager = nullptr,
    const std::vector<flatbuffers::Offset<HeroTemplate>> *hero_tpl_manager = nullptr) {
  return mengde::save::CreateResourceManagers(
      _fbb,
      terrain_manager ? _fbb.CreateVector<flatbuffers::Offset<Terrain>>(*terrain_manager) : 0,
      hero_class_manager ? _fbb.CreateVector<flatbuffers::Offset<HeroClass>>(*hero_class_manager) : 0,
      magic_manager ? _fbb.CreateVector<flatbuffers::Offset<Magic>>(*magic_manager) : 0,
      equipment_manager ? _fbb.CreateVector<flatbuffers::Offset<Equipment>>(*equipment_manager) : 0,
      hero_tpl_manager ? _fbb.CreateVector<flatbuffers::Offset<HeroTemplate>>(*hero_tpl_manager) : 0);
}

struct TerrainRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TERRAIN = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const Terrain *terrain() const {
    return GetPointer<const Terrain *>(VT_TERRAIN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_TERRAIN) &&
           verifier.VerifyTable(terrain()) &&
           verifier.EndTable();
  }
};

struct TerrainRecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(TerrainRecord::VT_ID, id);
  }
  void add_terrain(flatbuffers::Offset<Terrain> terrain) {
    fbb_.AddOffset(TerrainRecord::VT_TERRAIN, terrain);
  }
  explicit TerrainRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerrainRecordBuilder &operator=(const TerrainRecordBuilder &);
  flatbuffers::Offset<TerrainRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerrainRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerrainRecord> CreateTerrainRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<Terrain> terrain = 0) {
  TerrainRecordBuilder builder_(_fbb);
  builder_.add_terrain(terrain);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TerrainRecord> CreateTerrainRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    flatbuffers::Offset<Terrain> terrain = 0) {
  return mengde::save::CreateTerrainRecord(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      terrain);
}

struct Terrain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_MOVE_COSTS = 6,
    VT_CLASS_EFFECTS = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<int32_t> *move_costs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MOVE_COSTS);
  }
  const flatbuffers::Vector<int32_t> *class_effects() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLASS_EFFECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MOVE_COSTS) &&
           verifier.VerifyVector(move_costs()) &&
           VerifyOffset(verifier, VT_CLASS_EFFECTS) &&
           verifier.VerifyVector(class_effects()) &&
           verifier.EndTable();
  }
};

struct TerrainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Terrain::VT_ID, id);
  }
  void add_move_costs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> move_costs) {
    fbb_.AddOffset(Terrain::VT_MOVE_COSTS, move_costs);
  }
  void add_class_effects(flatbuffers::Offset<flatbuffers::Vector<int32_t>> class_effects) {
    fbb_.AddOffset(Terrain::VT_CLASS_EFFECTS, class_effects);
  }
  explicit TerrainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerrainBuilder &operator=(const TerrainBuilder &);
  flatbuffers::Offset<Terrain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Terrain>(end);
    return o;
  }
};

inline flatbuffers::Offset<Terrain> CreateTerrain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> move_costs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> class_effects = 0) {
  TerrainBuilder builder_(_fbb);
  builder_.add_class_effects(class_effects);
  builder_.add_move_costs(move_costs);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Terrain> CreateTerrainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<int32_t> *move_costs = nullptr,
    const std::vector<int32_t> *class_effects = nullptr) {
  return mengde::save::CreateTerrain(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      move_costs ? _fbb.CreateVector<int32_t>(*move_costs) : 0,
      class_effects ? _fbb.CreateVector<int32_t>(*class_effects) : 0);
}

struct HeroTemplate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_HERO_CLASS = 6,
    VT_ATTR = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *hero_class() const {
    return GetPointer<const flatbuffers::String *>(VT_HERO_CLASS);
  }
  const Attribute *attr() const {
    return GetStruct<const Attribute *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_HERO_CLASS) &&
           verifier.VerifyString(hero_class()) &&
           VerifyField<Attribute>(verifier, VT_ATTR) &&
           verifier.EndTable();
  }
};

struct HeroTemplateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(HeroTemplate::VT_ID, id);
  }
  void add_hero_class(flatbuffers::Offset<flatbuffers::String> hero_class) {
    fbb_.AddOffset(HeroTemplate::VT_HERO_CLASS, hero_class);
  }
  void add_attr(const Attribute *attr) {
    fbb_.AddStruct(HeroTemplate::VT_ATTR, attr);
  }
  explicit HeroTemplateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroTemplateBuilder &operator=(const HeroTemplateBuilder &);
  flatbuffers::Offset<HeroTemplate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeroTemplate>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroTemplate> CreateHeroTemplate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> hero_class = 0,
    const Attribute *attr = 0) {
  HeroTemplateBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_hero_class(hero_class);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroTemplate> CreateHeroTemplateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *hero_class = nullptr,
    const Attribute *attr = 0) {
  return mengde::save::CreateHeroTemplate(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      hero_class ? _fbb.CreateString(hero_class) : 0,
      attr);
}

struct HeroClass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_ATTR_GRADE = 6,
    VT_ATTACK_RANGE = 8,
    VT_MOVE = 10,
    VT_BI_HP = 12,
    VT_BI_MP = 14,
    VT_PROMOTION_INFO = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const Attribute *attr_grade() const {
    return GetStruct<const Attribute *>(VT_ATTR_GRADE);
  }
  int32_t attack_range() const {
    return GetField<int32_t>(VT_ATTACK_RANGE, 0);
  }
  int32_t move() const {
    return GetField<int32_t>(VT_MOVE, 0);
  }
  const BaseIncr *bi_hp() const {
    return GetStruct<const BaseIncr *>(VT_BI_HP);
  }
  const BaseIncr *bi_mp() const {
    return GetStruct<const BaseIncr *>(VT_BI_MP);
  }
  const PromotionInfo *promotion_info() const {
    return GetPointer<const PromotionInfo *>(VT_PROMOTION_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<Attribute>(verifier, VT_ATTR_GRADE) &&
           VerifyField<int32_t>(verifier, VT_ATTACK_RANGE) &&
           VerifyField<int32_t>(verifier, VT_MOVE) &&
           VerifyField<BaseIncr>(verifier, VT_BI_HP) &&
           VerifyField<BaseIncr>(verifier, VT_BI_MP) &&
           VerifyOffset(verifier, VT_PROMOTION_INFO) &&
           verifier.VerifyTable(promotion_info()) &&
           verifier.EndTable();
  }
};

struct HeroClassBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(HeroClass::VT_ID, id);
  }
  void add_attr_grade(const Attribute *attr_grade) {
    fbb_.AddStruct(HeroClass::VT_ATTR_GRADE, attr_grade);
  }
  void add_attack_range(int32_t attack_range) {
    fbb_.AddElement<int32_t>(HeroClass::VT_ATTACK_RANGE, attack_range, 0);
  }
  void add_move(int32_t move) {
    fbb_.AddElement<int32_t>(HeroClass::VT_MOVE, move, 0);
  }
  void add_bi_hp(const BaseIncr *bi_hp) {
    fbb_.AddStruct(HeroClass::VT_BI_HP, bi_hp);
  }
  void add_bi_mp(const BaseIncr *bi_mp) {
    fbb_.AddStruct(HeroClass::VT_BI_MP, bi_mp);
  }
  void add_promotion_info(flatbuffers::Offset<PromotionInfo> promotion_info) {
    fbb_.AddOffset(HeroClass::VT_PROMOTION_INFO, promotion_info);
  }
  explicit HeroClassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroClassBuilder &operator=(const HeroClassBuilder &);
  flatbuffers::Offset<HeroClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeroClass>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroClass> CreateHeroClass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    const Attribute *attr_grade = 0,
    int32_t attack_range = 0,
    int32_t move = 0,
    const BaseIncr *bi_hp = 0,
    const BaseIncr *bi_mp = 0,
    flatbuffers::Offset<PromotionInfo> promotion_info = 0) {
  HeroClassBuilder builder_(_fbb);
  builder_.add_promotion_info(promotion_info);
  builder_.add_bi_mp(bi_mp);
  builder_.add_bi_hp(bi_hp);
  builder_.add_move(move);
  builder_.add_attack_range(attack_range);
  builder_.add_attr_grade(attr_grade);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroClass> CreateHeroClassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const Attribute *attr_grade = 0,
    int32_t attack_range = 0,
    int32_t move = 0,
    const BaseIncr *bi_hp = 0,
    const BaseIncr *bi_mp = 0,
    flatbuffers::Offset<PromotionInfo> promotion_info = 0) {
  return mengde::save::CreateHeroClass(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      attr_grade,
      attack_range,
      move,
      bi_hp,
      bi_mp,
      promotion_info);
}

struct PromotionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HERO_CLASS_ID = 4,
    VT_LEVEL = 6
  };
  const flatbuffers::String *hero_class_id() const {
    return GetPointer<const flatbuffers::String *>(VT_HERO_CLASS_ID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HERO_CLASS_ID) &&
           verifier.VerifyString(hero_class_id()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct PromotionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_class_id(flatbuffers::Offset<flatbuffers::String> hero_class_id) {
    fbb_.AddOffset(PromotionInfo::VT_HERO_CLASS_ID, hero_class_id);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PromotionInfo::VT_LEVEL, level, 0);
  }
  explicit PromotionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PromotionInfoBuilder &operator=(const PromotionInfoBuilder &);
  flatbuffers::Offset<PromotionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PromotionInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PromotionInfo> CreatePromotionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hero_class_id = 0,
    int32_t level = 0) {
  PromotionInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_hero_class_id(hero_class_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<PromotionInfo> CreatePromotionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hero_class_id = nullptr,
    int32_t level = 0) {
  return mengde::save::CreatePromotionInfo(
      _fbb,
      hero_class_id ? _fbb.CreateString(hero_class_id) : 0,
      level);
}

struct Equipment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_VOLATILE_ATTRIBUTES = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const VolatileAttributes *volatile_attributes() const {
    return GetPointer<const VolatileAttributes *>(VT_VOLATILE_ATTRIBUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VOLATILE_ATTRIBUTES) &&
           verifier.VerifyTable(volatile_attributes()) &&
           verifier.EndTable();
  }
};

struct EquipmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Equipment::VT_ID, id);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Equipment::VT_TYPE, type, 0);
  }
  void add_volatile_attributes(flatbuffers::Offset<VolatileAttributes> volatile_attributes) {
    fbb_.AddOffset(Equipment::VT_VOLATILE_ATTRIBUTES, volatile_attributes);
  }
  explicit EquipmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentBuilder &operator=(const EquipmentBuilder &);
  flatbuffers::Offset<Equipment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equipment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equipment> CreateEquipment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t type = 0,
    flatbuffers::Offset<VolatileAttributes> volatile_attributes = 0) {
  EquipmentBuilder builder_(_fbb);
  builder_.add_volatile_attributes(volatile_attributes);
  builder_.add_type(type);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Equipment> CreateEquipmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t type = 0,
    flatbuffers::Offset<VolatileAttributes> volatile_attributes = 0) {
  return mengde::save::CreateEquipment(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      type,
      volatile_attributes);
}

struct VolatileAttributes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTRIBUTE_MODIFIER_LIST = 4,
    VT_EVENT_EFFECT_LIST = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>> *attribute_modifier_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>> *>(VT_ATTRIBUTE_MODIFIER_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventEffect>> *event_effect_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventEffect>> *>(VT_EVENT_EFFECT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTE_MODIFIER_LIST) &&
           verifier.VerifyVector(attribute_modifier_list()) &&
           verifier.VerifyVectorOfTables(attribute_modifier_list()) &&
           VerifyOffset(verifier, VT_EVENT_EFFECT_LIST) &&
           verifier.VerifyVector(event_effect_list()) &&
           verifier.VerifyVectorOfTables(event_effect_list()) &&
           verifier.EndTable();
  }
};

struct VolatileAttributesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attribute_modifier_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>>> attribute_modifier_list) {
    fbb_.AddOffset(VolatileAttributes::VT_ATTRIBUTE_MODIFIER_LIST, attribute_modifier_list);
  }
  void add_event_effect_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventEffect>>> event_effect_list) {
    fbb_.AddOffset(VolatileAttributes::VT_EVENT_EFFECT_LIST, event_effect_list);
  }
  explicit VolatileAttributesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VolatileAttributesBuilder &operator=(const VolatileAttributesBuilder &);
  flatbuffers::Offset<VolatileAttributes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VolatileAttributes>(end);
    return o;
  }
};

inline flatbuffers::Offset<VolatileAttributes> CreateVolatileAttributes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>>> attribute_modifier_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventEffect>>> event_effect_list = 0) {
  VolatileAttributesBuilder builder_(_fbb);
  builder_.add_event_effect_list(event_effect_list);
  builder_.add_attribute_modifier_list(attribute_modifier_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<VolatileAttributes> CreateVolatileAttributesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttributeModifier>> *attribute_modifier_list = nullptr,
    const std::vector<flatbuffers::Offset<EventEffect>> *event_effect_list = nullptr) {
  return mengde::save::CreateVolatileAttributes(
      _fbb,
      attribute_modifier_list ? _fbb.CreateVector<flatbuffers::Offset<AttributeModifier>>(*attribute_modifier_list) : 0,
      event_effect_list ? _fbb.CreateVector<flatbuffers::Offset<EventEffect>>(*event_effect_list) : 0);
}

struct AttributeModifier FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_STAT_IDX = 6,
    VT_TURN = 8,
    VT_MOD = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  uint16_t stat_idx() const {
    return GetField<uint16_t>(VT_STAT_IDX, 0);
  }
  const TurnBased *turn() const {
    return GetStruct<const TurnBased *>(VT_TURN);
  }
  const StatMod *mod() const {
    return GetStruct<const StatMod *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint16_t>(verifier, VT_STAT_IDX) &&
           VerifyField<TurnBased>(verifier, VT_TURN) &&
           VerifyField<StatMod>(verifier, VT_MOD) &&
           verifier.EndTable();
  }
};

struct AttributeModifierBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(AttributeModifier::VT_ID, id);
  }
  void add_stat_idx(uint16_t stat_idx) {
    fbb_.AddElement<uint16_t>(AttributeModifier::VT_STAT_IDX, stat_idx, 0);
  }
  void add_turn(const TurnBased *turn) {
    fbb_.AddStruct(AttributeModifier::VT_TURN, turn);
  }
  void add_mod(const StatMod *mod) {
    fbb_.AddStruct(AttributeModifier::VT_MOD, mod);
  }
  explicit AttributeModifierBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeModifierBuilder &operator=(const AttributeModifierBuilder &);
  flatbuffers::Offset<AttributeModifier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeModifier>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeModifier> CreateAttributeModifier(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    uint16_t stat_idx = 0,
    const TurnBased *turn = 0,
    const StatMod *mod = 0) {
  AttributeModifierBuilder builder_(_fbb);
  builder_.add_mod(mod);
  builder_.add_turn(turn);
  builder_.add_id(id);
  builder_.add_stat_idx(stat_idx);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeModifier> CreateAttributeModifierDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    uint16_t stat_idx = 0,
    const TurnBased *turn = 0,
    const StatMod *mod = 0) {
  return mengde::save::CreateAttributeModifier(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      stat_idx,
      turn,
      mod);
}

struct EventEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TURN = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  const TurnBased *turn() const {
    return GetStruct<const TurnBased *>(VT_TURN);
  }
  EventEffectImpl instance_type() const {
    return static_cast<EventEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const GeneralEventEffect *instance_as_GeneralEventEffect() const {
    return instance_type() == EventEffectImpl::GeneralEventEffect ? static_cast<const GeneralEventEffect *>(instance()) : nullptr;
  }
  const OnCmdEventEffect *instance_as_OnCmdEventEffect() const {
    return instance_type() == EventEffectImpl::OnCmdEventEffect ? static_cast<const OnCmdEventEffect *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TurnBased>(verifier, VT_TURN) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyEventEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GeneralEventEffect *EventEffect::instance_as<GeneralEventEffect>() const {
  return instance_as_GeneralEventEffect();
}

template<> inline const OnCmdEventEffect *EventEffect::instance_as<OnCmdEventEffect>() const {
  return instance_as_OnCmdEventEffect();
}

struct EventEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_turn(const TurnBased *turn) {
    fbb_.AddStruct(EventEffect::VT_TURN, turn);
  }
  void add_instance_type(EventEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(EventEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(EventEffect::VT_INSTANCE, instance);
  }
  explicit EventEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventEffectBuilder &operator=(const EventEffectBuilder &);
  flatbuffers::Offset<EventEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventEffect> CreateEventEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TurnBased *turn = 0,
    EventEffectImpl instance_type = EventEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  EventEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_turn(turn);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct GeneralEventEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  GeneralEventEffectImpl instance_type() const {
    return static_cast<GeneralEventEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const GEERestoreHp *instance_as_GEERestoreHp() const {
    return instance_type() == GeneralEventEffectImpl::GEERestoreHp ? static_cast<const GEERestoreHp *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyGeneralEventEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GEERestoreHp *GeneralEventEffect::instance_as<GEERestoreHp>() const {
  return instance_as_GEERestoreHp();
}

struct GeneralEventEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GeneralEventEffect::VT_TYPE, type, 0);
  }
  void add_instance_type(GeneralEventEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(GeneralEventEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(GeneralEventEffect::VT_INSTANCE, instance);
  }
  explicit GeneralEventEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeneralEventEffectBuilder &operator=(const GeneralEventEffectBuilder &);
  flatbuffers::Offset<GeneralEventEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeneralEventEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeneralEventEffect> CreateGeneralEventEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    GeneralEventEffectImpl instance_type = GeneralEventEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  GeneralEventEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_type(type);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct GEERestoreHp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MOD = 4
  };
  const StatMod *mod() const {
    return GetStruct<const StatMod *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<StatMod>(verifier, VT_MOD) &&
           verifier.EndTable();
  }
};

struct GEERestoreHpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mod(const StatMod *mod) {
    fbb_.AddStruct(GEERestoreHp::VT_MOD, mod);
  }
  explicit GEERestoreHpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEERestoreHpBuilder &operator=(const GEERestoreHpBuilder &);
  flatbuffers::Offset<GEERestoreHp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GEERestoreHp>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEERestoreHp> CreateGEERestoreHp(
    flatbuffers::FlatBufferBuilder &_fbb,
    const StatMod *mod = 0) {
  GEERestoreHpBuilder builder_(_fbb);
  builder_.add_mod(mod);
  return builder_.Finish();
}

struct OnCmdEventEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  OnCmdEventEffectImpl instance_type() const {
    return static_cast<OnCmdEventEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const OCEEPreemptiveAttack *instance_as_OCEEPreemptiveAttack() const {
    return instance_type() == OnCmdEventEffectImpl::OCEEPreemptiveAttack ? static_cast<const OCEEPreemptiveAttack *>(instance()) : nullptr;
  }
  const OCEEEnhanceBasicAttack *instance_as_OCEEEnhanceBasicAttack() const {
    return instance_type() == OnCmdEventEffectImpl::OCEEEnhanceBasicAttack ? static_cast<const OCEEEnhanceBasicAttack *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyOnCmdEventEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OCEEPreemptiveAttack *OnCmdEventEffect::instance_as<OCEEPreemptiveAttack>() const {
  return instance_as_OCEEPreemptiveAttack();
}

template<> inline const OCEEEnhanceBasicAttack *OnCmdEventEffect::instance_as<OCEEEnhanceBasicAttack>() const {
  return instance_as_OCEEEnhanceBasicAttack();
}

struct OnCmdEventEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(OnCmdEventEffect::VT_TYPE, type, 0);
  }
  void add_instance_type(OnCmdEventEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(OnCmdEventEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(OnCmdEventEffect::VT_INSTANCE, instance);
  }
  explicit OnCmdEventEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnCmdEventEffectBuilder &operator=(const OnCmdEventEffectBuilder &);
  flatbuffers::Offset<OnCmdEventEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnCmdEventEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnCmdEventEffect> CreateOnCmdEventEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    OnCmdEventEffectImpl instance_type = OnCmdEventEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  OnCmdEventEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_type(type);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct OCEEPreemptiveAttack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OCEEPreemptiveAttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OCEEPreemptiveAttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OCEEPreemptiveAttackBuilder &operator=(const OCEEPreemptiveAttackBuilder &);
  flatbuffers::Offset<OCEEPreemptiveAttack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OCEEPreemptiveAttack>(end);
    return o;
  }
};

inline flatbuffers::Offset<OCEEPreemptiveAttack> CreateOCEEPreemptiveAttack(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OCEEPreemptiveAttackBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OCEEEnhanceBasicAttack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MOD = 4
  };
  const StatMod *mod() const {
    return GetStruct<const StatMod *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<StatMod>(verifier, VT_MOD) &&
           verifier.EndTable();
  }
};

struct OCEEEnhanceBasicAttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mod(const StatMod *mod) {
    fbb_.AddStruct(OCEEEnhanceBasicAttack::VT_MOD, mod);
  }
  explicit OCEEEnhanceBasicAttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OCEEEnhanceBasicAttackBuilder &operator=(const OCEEEnhanceBasicAttackBuilder &);
  flatbuffers::Offset<OCEEEnhanceBasicAttack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OCEEEnhanceBasicAttack>(end);
    return o;
  }
};

inline flatbuffers::Offset<OCEEEnhanceBasicAttack> CreateOCEEEnhanceBasicAttack(
    flatbuffers::FlatBufferBuilder &_fbb,
    const StatMod *mod = 0) {
  OCEEEnhanceBasicAttackBuilder builder_(_fbb);
  builder_.add_mod(mod);
  return builder_.Finish();
}

struct Magic FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_RANGE = 6,
    VT_LEARN_INFO_LIST = 8,
    VT_TARGET_ENEMY = 10,
    VT_MP_COST = 12,
    VT_EFFECTS = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t range() const {
    return GetField<int32_t>(VT_RANGE, 0);
  }
  const flatbuffers::Vector<const LearnInfo *> *learn_info_list() const {
    return GetPointer<const flatbuffers::Vector<const LearnInfo *> *>(VT_LEARN_INFO_LIST);
  }
  bool target_enemy() const {
    return GetField<uint8_t>(VT_TARGET_ENEMY, 0) != 0;
  }
  uint16_t mp_cost() const {
    return GetField<uint16_t>(VT_MP_COST, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MagicEffect>> *effects() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MagicEffect>> *>(VT_EFFECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_RANGE) &&
           VerifyOffset(verifier, VT_LEARN_INFO_LIST) &&
           verifier.VerifyVector(learn_info_list()) &&
           VerifyField<uint8_t>(verifier, VT_TARGET_ENEMY) &&
           VerifyField<uint16_t>(verifier, VT_MP_COST) &&
           VerifyOffset(verifier, VT_EFFECTS) &&
           verifier.VerifyVector(effects()) &&
           verifier.VerifyVectorOfTables(effects()) &&
           verifier.EndTable();
  }
};

struct MagicBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Magic::VT_ID, id);
  }
  void add_range(int32_t range) {
    fbb_.AddElement<int32_t>(Magic::VT_RANGE, range, 0);
  }
  void add_learn_info_list(flatbuffers::Offset<flatbuffers::Vector<const LearnInfo *>> learn_info_list) {
    fbb_.AddOffset(Magic::VT_LEARN_INFO_LIST, learn_info_list);
  }
  void add_target_enemy(bool target_enemy) {
    fbb_.AddElement<uint8_t>(Magic::VT_TARGET_ENEMY, static_cast<uint8_t>(target_enemy), 0);
  }
  void add_mp_cost(uint16_t mp_cost) {
    fbb_.AddElement<uint16_t>(Magic::VT_MP_COST, mp_cost, 0);
  }
  void add_effects(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MagicEffect>>> effects) {
    fbb_.AddOffset(Magic::VT_EFFECTS, effects);
  }
  explicit MagicBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MagicBuilder &operator=(const MagicBuilder &);
  flatbuffers::Offset<Magic> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Magic>(end);
    return o;
  }
};

inline flatbuffers::Offset<Magic> CreateMagic(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t range = 0,
    flatbuffers::Offset<flatbuffers::Vector<const LearnInfo *>> learn_info_list = 0,
    bool target_enemy = false,
    uint16_t mp_cost = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MagicEffect>>> effects = 0) {
  MagicBuilder builder_(_fbb);
  builder_.add_effects(effects);
  builder_.add_learn_info_list(learn_info_list);
  builder_.add_range(range);
  builder_.add_id(id);
  builder_.add_mp_cost(mp_cost);
  builder_.add_target_enemy(target_enemy);
  return builder_.Finish();
}

inline flatbuffers::Offset<Magic> CreateMagicDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t range = 0,
    const std::vector<LearnInfo> *learn_info_list = nullptr,
    bool target_enemy = false,
    uint16_t mp_cost = 0,
    const std::vector<flatbuffers::Offset<MagicEffect>> *effects = nullptr) {
  return mengde::save::CreateMagic(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      range,
      learn_info_list ? _fbb.CreateVectorOfStructs<LearnInfo>(*learn_info_list) : 0,
      target_enemy,
      mp_cost,
      effects ? _fbb.CreateVector<flatbuffers::Offset<MagicEffect>>(*effects) : 0);
}

struct MagicEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  MagicEffectImpl instance_type() const {
    return static_cast<MagicEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const MagicEffectHp *instance_as_MagicEffectHp() const {
    return instance_type() == MagicEffectImpl::MagicEffectHp ? static_cast<const MagicEffectHp *>(instance()) : nullptr;
  }
  const MagicEffectAttribute *instance_as_MagicEffectAttribute() const {
    return instance_type() == MagicEffectImpl::MagicEffectAttribute ? static_cast<const MagicEffectAttribute *>(instance()) : nullptr;
  }
  const MagicEffectCondition *instance_as_MagicEffectCondition() const {
    return instance_type() == MagicEffectImpl::MagicEffectCondition ? static_cast<const MagicEffectCondition *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyMagicEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const MagicEffectHp *MagicEffect::instance_as<MagicEffectHp>() const {
  return instance_as_MagicEffectHp();
}

template<> inline const MagicEffectAttribute *MagicEffect::instance_as<MagicEffectAttribute>() const {
  return instance_as_MagicEffectAttribute();
}

template<> inline const MagicEffectCondition *MagicEffect::instance_as<MagicEffectCondition>() const {
  return instance_as_MagicEffectCondition();
}

struct MagicEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MagicEffect::VT_TYPE, type, 0);
  }
  void add_instance_type(MagicEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(MagicEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(MagicEffect::VT_INSTANCE, instance);
  }
  explicit MagicEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MagicEffectBuilder &operator=(const MagicEffectBuilder &);
  flatbuffers::Offset<MagicEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MagicEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<MagicEffect> CreateMagicEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    MagicEffectImpl instance_type = MagicEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  MagicEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_type(type);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct MagicEffectHp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POWER = 4
  };
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           verifier.EndTable();
  }
};

struct MagicEffectHpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(MagicEffectHp::VT_POWER, power, 0);
  }
  explicit MagicEffectHpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MagicEffectHpBuilder &operator=(const MagicEffectHpBuilder &);
  flatbuffers::Offset<MagicEffectHp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MagicEffectHp>(end);
    return o;
  }
};

inline flatbuffers::Offset<MagicEffectHp> CreateMagicEffectHp(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t power = 0) {
  MagicEffectHpBuilder builder_(_fbb);
  builder_.add_power(power);
  return builder_.Finish();
}

struct MagicEffectAttribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTRIBUTE_MODIFIER = 4
  };
  const AttributeModifier *attribute_modifier() const {
    return GetPointer<const AttributeModifier *>(VT_ATTRIBUTE_MODIFIER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTE_MODIFIER) &&
           verifier.VerifyTable(attribute_modifier()) &&
           verifier.EndTable();
  }
};

struct MagicEffectAttributeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attribute_modifier(flatbuffers::Offset<AttributeModifier> attribute_modifier) {
    fbb_.AddOffset(MagicEffectAttribute::VT_ATTRIBUTE_MODIFIER, attribute_modifier);
  }
  explicit MagicEffectAttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MagicEffectAttributeBuilder &operator=(const MagicEffectAttributeBuilder &);
  flatbuffers::Offset<MagicEffectAttribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MagicEffectAttribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<MagicEffectAttribute> CreateMagicEffectAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttributeModifier> attribute_modifier = 0) {
  MagicEffectAttributeBuilder builder_(_fbb);
  builder_.add_attribute_modifier(attribute_modifier);
  return builder_.Finish();
}

struct MagicEffectCondition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONDITION = 4,
    VT_TURN = 6
  };
  int32_t condition() const {
    return GetField<int32_t>(VT_CONDITION, 0);
  }
  const TurnBased *turn() const {
    return GetStruct<const TurnBased *>(VT_TURN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CONDITION) &&
           VerifyField<TurnBased>(verifier, VT_TURN) &&
           verifier.EndTable();
  }
};

struct MagicEffectConditionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condition(int32_t condition) {
    fbb_.AddElement<int32_t>(MagicEffectCondition::VT_CONDITION, condition, 0);
  }
  void add_turn(const TurnBased *turn) {
    fbb_.AddStruct(MagicEffectCondition::VT_TURN, turn);
  }
  explicit MagicEffectConditionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MagicEffectConditionBuilder &operator=(const MagicEffectConditionBuilder &);
  flatbuffers::Offset<MagicEffectCondition> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MagicEffectCondition>(end);
    return o;
  }
};

inline flatbuffers::Offset<MagicEffectCondition> CreateMagicEffectCondition(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t condition = 0,
    const TurnBased *turn = 0) {
  MagicEffectConditionBuilder builder_(_fbb);
  builder_.add_turn(turn);
  builder_.add_condition(condition);
  return builder_.Finish();
}

struct Assets FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MONEY = 4,
    VT_HEROES = 6,
    VT_EQUIPMENTS = 8
  };
  uint32_t money() const {
    return GetField<uint32_t>(VT_MONEY, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Hero>> *heroes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Hero>> *>(VT_HEROES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EquipmentWithAmount>> *equipments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EquipmentWithAmount>> *>(VT_EQUIPMENTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MONEY) &&
           VerifyOffset(verifier, VT_HEROES) &&
           verifier.VerifyVector(heroes()) &&
           verifier.VerifyVectorOfTables(heroes()) &&
           VerifyOffset(verifier, VT_EQUIPMENTS) &&
           verifier.VerifyVector(equipments()) &&
           verifier.VerifyVectorOfTables(equipments()) &&
           verifier.EndTable();
  }
};

struct AssetsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_money(uint32_t money) {
    fbb_.AddElement<uint32_t>(Assets::VT_MONEY, money, 0);
  }
  void add_heroes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Hero>>> heroes) {
    fbb_.AddOffset(Assets::VT_HEROES, heroes);
  }
  void add_equipments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EquipmentWithAmount>>> equipments) {
    fbb_.AddOffset(Assets::VT_EQUIPMENTS, equipments);
  }
  explicit AssetsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssetsBuilder &operator=(const AssetsBuilder &);
  flatbuffers::Offset<Assets> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assets>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assets> CreateAssets(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t money = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Hero>>> heroes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EquipmentWithAmount>>> equipments = 0) {
  AssetsBuilder builder_(_fbb);
  builder_.add_equipments(equipments);
  builder_.add_heroes(heroes);
  builder_.add_money(money);
  return builder_.Finish();
}

inline flatbuffers::Offset<Assets> CreateAssetsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t money = 0,
    const std::vector<flatbuffers::Offset<Hero>> *heroes = nullptr,
    const std::vector<flatbuffers::Offset<EquipmentWithAmount>> *equipments = nullptr) {
  return mengde::save::CreateAssets(
      _fbb,
      money,
      heroes ? _fbb.CreateVector<flatbuffers::Offset<Hero>>(*heroes) : 0,
      equipments ? _fbb.CreateVector<flatbuffers::Offset<EquipmentWithAmount>>(*equipments) : 0);
}

struct EquipmentWithAmount FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_EQUIPMENT = 4,
    VT_AMOUNT = 6
  };
  const flatbuffers::String *equipment() const {
    return GetPointer<const flatbuffers::String *>(VT_EQUIPMENT);
  }
  uint32_t amount() const {
    return GetField<uint32_t>(VT_AMOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EQUIPMENT) &&
           verifier.VerifyString(equipment()) &&
           VerifyField<uint32_t>(verifier, VT_AMOUNT) &&
           verifier.EndTable();
  }
};

struct EquipmentWithAmountBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_equipment(flatbuffers::Offset<flatbuffers::String> equipment) {
    fbb_.AddOffset(EquipmentWithAmount::VT_EQUIPMENT, equipment);
  }
  void add_amount(uint32_t amount) {
    fbb_.AddElement<uint32_t>(EquipmentWithAmount::VT_AMOUNT, amount, 0);
  }
  explicit EquipmentWithAmountBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentWithAmountBuilder &operator=(const EquipmentWithAmountBuilder &);
  flatbuffers::Offset<EquipmentWithAmount> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipmentWithAmount>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipmentWithAmount> CreateEquipmentWithAmount(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> equipment = 0,
    uint32_t amount = 0) {
  EquipmentWithAmountBuilder builder_(_fbb);
  builder_.add_amount(amount);
  builder_.add_equipment(equipment);
  return builder_.Finish();
}

inline flatbuffers::Offset<EquipmentWithAmount> CreateEquipmentWithAmountDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *equipment = nullptr,
    uint32_t amount = 0) {
  return mengde::save::CreateEquipmentWithAmount(
      _fbb,
      equipment ? _fbb.CreateString(equipment) : 0,
      amount);
}

struct Hero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_HERO_CLASS = 6,
    VT_HERO_ATTR = 8,
    VT_EQUIPMENT_SET = 10,
    VT_LEVEL = 12,
    VT_HP = 14,
    VT_MP = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *hero_class() const {
    return GetPointer<const flatbuffers::String *>(VT_HERO_CLASS);
  }
  const Attribute *hero_attr() const {
    return GetStruct<const Attribute *>(VT_HERO_ATTR);
  }
  const EquipmentSet *equipment_set() const {
    return GetPointer<const EquipmentSet *>(VT_EQUIPMENT_SET);
  }
  const LevelExp *level() const {
    return GetStruct<const LevelExp *>(VT_LEVEL);
  }
  uint32_t hp() const {
    return GetField<uint32_t>(VT_HP, 0);
  }
  uint32_t mp() const {
    return GetField<uint32_t>(VT_MP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_HERO_CLASS) &&
           verifier.VerifyString(hero_class()) &&
           VerifyField<Attribute>(verifier, VT_HERO_ATTR) &&
           VerifyOffset(verifier, VT_EQUIPMENT_SET) &&
           verifier.VerifyTable(equipment_set()) &&
           VerifyField<LevelExp>(verifier, VT_LEVEL) &&
           VerifyField<uint32_t>(verifier, VT_HP) &&
           VerifyField<uint32_t>(verifier, VT_MP) &&
           verifier.EndTable();
  }
};

struct HeroBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Hero::VT_ID, id);
  }
  void add_hero_class(flatbuffers::Offset<flatbuffers::String> hero_class) {
    fbb_.AddOffset(Hero::VT_HERO_CLASS, hero_class);
  }
  void add_hero_attr(const Attribute *hero_attr) {
    fbb_.AddStruct(Hero::VT_HERO_ATTR, hero_attr);
  }
  void add_equipment_set(flatbuffers::Offset<EquipmentSet> equipment_set) {
    fbb_.AddOffset(Hero::VT_EQUIPMENT_SET, equipment_set);
  }
  void add_level(const LevelExp *level) {
    fbb_.AddStruct(Hero::VT_LEVEL, level);
  }
  void add_hp(uint32_t hp) {
    fbb_.AddElement<uint32_t>(Hero::VT_HP, hp, 0);
  }
  void add_mp(uint32_t mp) {
    fbb_.AddElement<uint32_t>(Hero::VT_MP, mp, 0);
  }
  explicit HeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroBuilder &operator=(const HeroBuilder &);
  flatbuffers::Offset<Hero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Hero>(end);
    return o;
  }
};

inline flatbuffers::Offset<Hero> CreateHero(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> hero_class = 0,
    const Attribute *hero_attr = 0,
    flatbuffers::Offset<EquipmentSet> equipment_set = 0,
    const LevelExp *level = 0,
    uint32_t hp = 0,
    uint32_t mp = 0) {
  HeroBuilder builder_(_fbb);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_level(level);
  builder_.add_equipment_set(equipment_set);
  builder_.add_hero_attr(hero_attr);
  builder_.add_hero_class(hero_class);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Hero> CreateHeroDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *hero_class = nullptr,
    const Attribute *hero_attr = 0,
    flatbuffers::Offset<EquipmentSet> equipment_set = 0,
    const LevelExp *level = 0,
    uint32_t hp = 0,
    uint32_t mp = 0) {
  return mengde::save::CreateHero(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      hero_class ? _fbb.CreateString(hero_class) : 0,
      hero_attr,
      equipment_set,
      level,
      hp,
      mp);
}

struct EquipmentSet FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WEAPON = 4,
    VT_ARMOR = 6,
    VT_AID = 8
  };
  const flatbuffers::String *weapon() const {
    return GetPointer<const flatbuffers::String *>(VT_WEAPON);
  }
  const flatbuffers::String *armor() const {
    return GetPointer<const flatbuffers::String *>(VT_ARMOR);
  }
  const flatbuffers::String *aid() const {
    return GetPointer<const flatbuffers::String *>(VT_AID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WEAPON) &&
           verifier.VerifyString(weapon()) &&
           VerifyOffset(verifier, VT_ARMOR) &&
           verifier.VerifyString(armor()) &&
           VerifyOffset(verifier, VT_AID) &&
           verifier.VerifyString(aid()) &&
           verifier.EndTable();
  }
};

struct EquipmentSetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weapon(flatbuffers::Offset<flatbuffers::String> weapon) {
    fbb_.AddOffset(EquipmentSet::VT_WEAPON, weapon);
  }
  void add_armor(flatbuffers::Offset<flatbuffers::String> armor) {
    fbb_.AddOffset(EquipmentSet::VT_ARMOR, armor);
  }
  void add_aid(flatbuffers::Offset<flatbuffers::String> aid) {
    fbb_.AddOffset(EquipmentSet::VT_AID, aid);
  }
  explicit EquipmentSetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentSetBuilder &operator=(const EquipmentSetBuilder &);
  flatbuffers::Offset<EquipmentSet> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipmentSet>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipmentSet> CreateEquipmentSet(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> weapon = 0,
    flatbuffers::Offset<flatbuffers::String> armor = 0,
    flatbuffers::Offset<flatbuffers::String> aid = 0) {
  EquipmentSetBuilder builder_(_fbb);
  builder_.add_aid(aid);
  builder_.add_armor(armor);
  builder_.add_weapon(weapon);
  return builder_.Finish();
}

inline flatbuffers::Offset<EquipmentSet> CreateEquipmentSetDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *weapon = nullptr,
    const char *armor = nullptr,
    const char *aid = nullptr) {
  return mengde::save::CreateEquipmentSet(
      _fbb,
      weapon ? _fbb.CreateString(weapon) : 0,
      armor ? _fbb.CreateString(armor) : 0,
      aid ? _fbb.CreateString(aid) : 0);
}

inline bool VerifyEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, EventEffectImpl type) {
  switch (type) {
    case EventEffectImpl::NONE: {
      return true;
    }
    case EventEffectImpl::GeneralEventEffect: {
      auto ptr = reinterpret_cast<const GeneralEventEffect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventEffectImpl::OnCmdEventEffect: {
      auto ptr = reinterpret_cast<const OnCmdEventEffect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEventEffectImpl(
        verifier,  values->Get(i), types->GetEnum<EventEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGeneralEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, GeneralEventEffectImpl type) {
  switch (type) {
    case GeneralEventEffectImpl::NONE: {
      return true;
    }
    case GeneralEventEffectImpl::GEERestoreHp: {
      auto ptr = reinterpret_cast<const GEERestoreHp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyGeneralEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeneralEventEffectImpl(
        verifier,  values->Get(i), types->GetEnum<GeneralEventEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOnCmdEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, OnCmdEventEffectImpl type) {
  switch (type) {
    case OnCmdEventEffectImpl::NONE: {
      return true;
    }
    case OnCmdEventEffectImpl::OCEEPreemptiveAttack: {
      auto ptr = reinterpret_cast<const OCEEPreemptiveAttack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OnCmdEventEffectImpl::OCEEEnhanceBasicAttack: {
      auto ptr = reinterpret_cast<const OCEEEnhanceBasicAttack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOnCmdEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOnCmdEventEffectImpl(
        verifier,  values->Get(i), types->GetEnum<OnCmdEventEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyMagicEffectImpl(flatbuffers::Verifier &verifier, const void *obj, MagicEffectImpl type) {
  switch (type) {
    case MagicEffectImpl::NONE: {
      return true;
    }
    case MagicEffectImpl::MagicEffectHp: {
      auto ptr = reinterpret_cast<const MagicEffectHp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MagicEffectImpl::MagicEffectAttribute: {
      auto ptr = reinterpret_cast<const MagicEffectAttribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MagicEffectImpl::MagicEffectCondition: {
      auto ptr = reinterpret_cast<const MagicEffectCondition *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMagicEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMagicEffectImpl(
        verifier,  values->Get(i), types->GetEnum<MagicEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const mengde::save::Scenario *GetScenario(const void *buf) {
  return flatbuffers::GetRoot<mengde::save::Scenario>(buf);
}

inline const mengde::save::Scenario *GetSizePrefixedScenario(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mengde::save::Scenario>(buf);
}

inline bool VerifyScenarioBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mengde::save::Scenario>(nullptr);
}

inline bool VerifySizePrefixedScenarioBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mengde::save::Scenario>(nullptr);
}

inline void FinishScenarioBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mengde::save::Scenario> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedScenarioBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mengde::save::Scenario> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace save
}  // namespace mengde

#endif  // FLATBUFFERS_GENERATED_SCENARIO_MENGDE_SAVE_H_
