// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENARIO_MENGDE_SAVE_H_
#define FLATBUFFERS_GENERATED_SCENARIO_MENGDE_SAVE_H_

#include "flatbuffers/flatbuffers.h"

namespace mengde {
namespace save {

struct Scenario;

struct ResourceManagers;

struct TerrainManager;

struct HeroClassManager;

struct HeroTemplateManager;

struct TerrainRecord;

struct Terrain;

struct HeroTemplate;

struct HeroClass;

struct BaseIncr;

struct PromotionInfo;

struct Attribute;

struct Position;

struct EquipmentManager;

struct Equipment;

struct VolatileAttributes;

struct AttributeModifierList;

struct AttributeModifier;

struct TurnBased;

struct StatMod;

struct EventEffect;

struct GeneralEventEffect;

struct GEERestoreHp;

struct OnCmdEventEffect;

struct OCEEPreemptiveAttack;

struct OCEEEnhanceBasicAttack;

enum class EventEffectImpl : uint8_t {
  NONE = 0,
  GeneralEventEffect = 1,
  OnCmdEventEffect = 2,
  MIN = NONE,
  MAX = OnCmdEventEffect
};

inline const EventEffectImpl (&EnumValuesEventEffectImpl())[3] {
  static const EventEffectImpl values[] = {
    EventEffectImpl::NONE,
    EventEffectImpl::GeneralEventEffect,
    EventEffectImpl::OnCmdEventEffect
  };
  return values;
}

inline const char * const *EnumNamesEventEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "GeneralEventEffect",
    "OnCmdEventEffect",
    nullptr
  };
  return names;
}

inline const char *EnumNameEventEffectImpl(EventEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEventEffectImpl()[index];
}

template<typename T> struct EventEffectImplTraits {
  static const EventEffectImpl enum_value = EventEffectImpl::NONE;
};

template<> struct EventEffectImplTraits<GeneralEventEffect> {
  static const EventEffectImpl enum_value = EventEffectImpl::GeneralEventEffect;
};

template<> struct EventEffectImplTraits<OnCmdEventEffect> {
  static const EventEffectImpl enum_value = EventEffectImpl::OnCmdEventEffect;
};

bool VerifyEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, EventEffectImpl type);
bool VerifyEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class GeneralEventEffectImpl : uint8_t {
  NONE = 0,
  GEERestoreHp = 1,
  MIN = NONE,
  MAX = GEERestoreHp
};

inline const GeneralEventEffectImpl (&EnumValuesGeneralEventEffectImpl())[2] {
  static const GeneralEventEffectImpl values[] = {
    GeneralEventEffectImpl::NONE,
    GeneralEventEffectImpl::GEERestoreHp
  };
  return values;
}

inline const char * const *EnumNamesGeneralEventEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "GEERestoreHp",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeneralEventEffectImpl(GeneralEventEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGeneralEventEffectImpl()[index];
}

template<typename T> struct GeneralEventEffectImplTraits {
  static const GeneralEventEffectImpl enum_value = GeneralEventEffectImpl::NONE;
};

template<> struct GeneralEventEffectImplTraits<GEERestoreHp> {
  static const GeneralEventEffectImpl enum_value = GeneralEventEffectImpl::GEERestoreHp;
};

bool VerifyGeneralEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, GeneralEventEffectImpl type);
bool VerifyGeneralEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class OnCmdEventEffectImpl : uint8_t {
  NONE = 0,
  OCEEPreemptiveAttack = 1,
  OCEEEnhanceBasicAttack = 2,
  MIN = NONE,
  MAX = OCEEEnhanceBasicAttack
};

inline const OnCmdEventEffectImpl (&EnumValuesOnCmdEventEffectImpl())[3] {
  static const OnCmdEventEffectImpl values[] = {
    OnCmdEventEffectImpl::NONE,
    OnCmdEventEffectImpl::OCEEPreemptiveAttack,
    OnCmdEventEffectImpl::OCEEEnhanceBasicAttack
  };
  return values;
}

inline const char * const *EnumNamesOnCmdEventEffectImpl() {
  static const char * const names[] = {
    "NONE",
    "OCEEPreemptiveAttack",
    "OCEEEnhanceBasicAttack",
    nullptr
  };
  return names;
}

inline const char *EnumNameOnCmdEventEffectImpl(OnCmdEventEffectImpl e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOnCmdEventEffectImpl()[index];
}

template<typename T> struct OnCmdEventEffectImplTraits {
  static const OnCmdEventEffectImpl enum_value = OnCmdEventEffectImpl::NONE;
};

template<> struct OnCmdEventEffectImplTraits<OCEEPreemptiveAttack> {
  static const OnCmdEventEffectImpl enum_value = OnCmdEventEffectImpl::OCEEPreemptiveAttack;
};

template<> struct OnCmdEventEffectImplTraits<OCEEEnhanceBasicAttack> {
  static const OnCmdEventEffectImpl enum_value = OnCmdEventEffectImpl::OCEEEnhanceBasicAttack;
};

bool VerifyOnCmdEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, OnCmdEventEffectImpl type);
bool VerifyOnCmdEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) BaseIncr FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t base_;
  int32_t incr_;

 public:
  BaseIncr() {
    memset(this, 0, sizeof(BaseIncr));
  }
  BaseIncr(int32_t _base, int32_t _incr)
      : base_(flatbuffers::EndianScalar(_base)),
        incr_(flatbuffers::EndianScalar(_incr)) {
  }
  int32_t base() const {
    return flatbuffers::EndianScalar(base_);
  }
  int32_t incr() const {
    return flatbuffers::EndianScalar(incr_);
  }
};
FLATBUFFERS_STRUCT_END(BaseIncr, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Attribute FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t atk_;
  int32_t def_;
  int32_t dex_;
  int32_t itl_;
  int32_t mor_;

 public:
  Attribute() {
    memset(this, 0, sizeof(Attribute));
  }
  Attribute(int32_t _atk, int32_t _def, int32_t _dex, int32_t _itl, int32_t _mor)
      : atk_(flatbuffers::EndianScalar(_atk)),
        def_(flatbuffers::EndianScalar(_def)),
        dex_(flatbuffers::EndianScalar(_dex)),
        itl_(flatbuffers::EndianScalar(_itl)),
        mor_(flatbuffers::EndianScalar(_mor)) {
  }
  int32_t atk() const {
    return flatbuffers::EndianScalar(atk_);
  }
  int32_t def() const {
    return flatbuffers::EndianScalar(def_);
  }
  int32_t dex() const {
    return flatbuffers::EndianScalar(dex_);
  }
  int32_t itl() const {
    return flatbuffers::EndianScalar(itl_);
  }
  int32_t mor() const {
    return flatbuffers::EndianScalar(mor_);
  }
};
FLATBUFFERS_STRUCT_END(Attribute, 20);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Position FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Position() {
    memset(this, 0, sizeof(Position));
  }
  Position(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Position, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) TurnBased FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t turns_;

 public:
  TurnBased() {
    memset(this, 0, sizeof(TurnBased));
  }
  TurnBased(uint16_t _turns)
      : turns_(flatbuffers::EndianScalar(_turns)) {
  }
  uint16_t turns() const {
    return flatbuffers::EndianScalar(turns_);
  }
};
FLATBUFFERS_STRUCT_END(TurnBased, 2);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(2) StatMod FLATBUFFERS_FINAL_CLASS {
 private:
  int16_t addend_;
  int16_t multiplier_;

 public:
  StatMod() {
    memset(this, 0, sizeof(StatMod));
  }
  StatMod(int16_t _addend, int16_t _multiplier)
      : addend_(flatbuffers::EndianScalar(_addend)),
        multiplier_(flatbuffers::EndianScalar(_multiplier)) {
  }
  int16_t addend() const {
    return flatbuffers::EndianScalar(addend_);
  }
  int16_t multiplier() const {
    return flatbuffers::EndianScalar(multiplier_);
  }
};
FLATBUFFERS_STRUCT_END(StatMod, 4);

struct Scenario FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_STAGE_ID_LIST = 6,
    VT_STAGE_NO = 8,
    VT_RESOURCE_MANAGERS = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *stage_id_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STAGE_ID_LIST);
  }
  uint32_t stage_no() const {
    return GetField<uint32_t>(VT_STAGE_NO, 0);
  }
  const ResourceManagers *resource_managers() const {
    return GetPointer<const ResourceManagers *>(VT_RESOURCE_MANAGERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_STAGE_ID_LIST) &&
           verifier.VerifyVector(stage_id_list()) &&
           verifier.VerifyVectorOfStrings(stage_id_list()) &&
           VerifyField<uint32_t>(verifier, VT_STAGE_NO) &&
           VerifyOffset(verifier, VT_RESOURCE_MANAGERS) &&
           verifier.VerifyTable(resource_managers()) &&
           verifier.EndTable();
  }
};

struct ScenarioBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Scenario::VT_ID, id);
  }
  void add_stage_id_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> stage_id_list) {
    fbb_.AddOffset(Scenario::VT_STAGE_ID_LIST, stage_id_list);
  }
  void add_stage_no(uint32_t stage_no) {
    fbb_.AddElement<uint32_t>(Scenario::VT_STAGE_NO, stage_no, 0);
  }
  void add_resource_managers(flatbuffers::Offset<ResourceManagers> resource_managers) {
    fbb_.AddOffset(Scenario::VT_RESOURCE_MANAGERS, resource_managers);
  }
  explicit ScenarioBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScenarioBuilder &operator=(const ScenarioBuilder &);
  flatbuffers::Offset<Scenario> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scenario>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scenario> CreateScenario(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> stage_id_list = 0,
    uint32_t stage_no = 0,
    flatbuffers::Offset<ResourceManagers> resource_managers = 0) {
  ScenarioBuilder builder_(_fbb);
  builder_.add_resource_managers(resource_managers);
  builder_.add_stage_no(stage_no);
  builder_.add_stage_id_list(stage_id_list);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scenario> CreateScenarioDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *stage_id_list = nullptr,
    uint32_t stage_no = 0,
    flatbuffers::Offset<ResourceManagers> resource_managers = 0) {
  return mengde::save::CreateScenario(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      stage_id_list ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*stage_id_list) : 0,
      stage_no,
      resource_managers);
}

struct ResourceManagers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TERRAIN_MANAGER = 4,
    VT_HERO_CLASS_MANAGER = 6,
    VT_EQUIPMENT_MANAGER = 8,
    VT_HERO_TPL_MANAGER = 10
  };
  const TerrainManager *terrain_manager() const {
    return GetPointer<const TerrainManager *>(VT_TERRAIN_MANAGER);
  }
  const HeroClassManager *hero_class_manager() const {
    return GetPointer<const HeroClassManager *>(VT_HERO_CLASS_MANAGER);
  }
  const EquipmentManager *equipment_manager() const {
    return GetPointer<const EquipmentManager *>(VT_EQUIPMENT_MANAGER);
  }
  const HeroTemplateManager *hero_tpl_manager() const {
    return GetPointer<const HeroTemplateManager *>(VT_HERO_TPL_MANAGER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TERRAIN_MANAGER) &&
           verifier.VerifyTable(terrain_manager()) &&
           VerifyOffset(verifier, VT_HERO_CLASS_MANAGER) &&
           verifier.VerifyTable(hero_class_manager()) &&
           VerifyOffset(verifier, VT_EQUIPMENT_MANAGER) &&
           verifier.VerifyTable(equipment_manager()) &&
           VerifyOffset(verifier, VT_HERO_TPL_MANAGER) &&
           verifier.VerifyTable(hero_tpl_manager()) &&
           verifier.EndTable();
  }
};

struct ResourceManagersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_terrain_manager(flatbuffers::Offset<TerrainManager> terrain_manager) {
    fbb_.AddOffset(ResourceManagers::VT_TERRAIN_MANAGER, terrain_manager);
  }
  void add_hero_class_manager(flatbuffers::Offset<HeroClassManager> hero_class_manager) {
    fbb_.AddOffset(ResourceManagers::VT_HERO_CLASS_MANAGER, hero_class_manager);
  }
  void add_equipment_manager(flatbuffers::Offset<EquipmentManager> equipment_manager) {
    fbb_.AddOffset(ResourceManagers::VT_EQUIPMENT_MANAGER, equipment_manager);
  }
  void add_hero_tpl_manager(flatbuffers::Offset<HeroTemplateManager> hero_tpl_manager) {
    fbb_.AddOffset(ResourceManagers::VT_HERO_TPL_MANAGER, hero_tpl_manager);
  }
  explicit ResourceManagersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResourceManagersBuilder &operator=(const ResourceManagersBuilder &);
  flatbuffers::Offset<ResourceManagers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResourceManagers>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResourceManagers> CreateResourceManagers(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<TerrainManager> terrain_manager = 0,
    flatbuffers::Offset<HeroClassManager> hero_class_manager = 0,
    flatbuffers::Offset<EquipmentManager> equipment_manager = 0,
    flatbuffers::Offset<HeroTemplateManager> hero_tpl_manager = 0) {
  ResourceManagersBuilder builder_(_fbb);
  builder_.add_hero_tpl_manager(hero_tpl_manager);
  builder_.add_equipment_manager(equipment_manager);
  builder_.add_hero_class_manager(hero_class_manager);
  builder_.add_terrain_manager(terrain_manager);
  return builder_.Finish();
}

struct TerrainManager FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TerrainRecord>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TerrainRecord>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct TerrainManagerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TerrainRecord>>> records) {
    fbb_.AddOffset(TerrainManager::VT_RECORDS, records);
  }
  explicit TerrainManagerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerrainManagerBuilder &operator=(const TerrainManagerBuilder &);
  flatbuffers::Offset<TerrainManager> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerrainManager>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerrainManager> CreateTerrainManager(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TerrainRecord>>> records = 0) {
  TerrainManagerBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<TerrainManager> CreateTerrainManagerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TerrainRecord>> *records = nullptr) {
  return mengde::save::CreateTerrainManager(
      _fbb,
      records ? _fbb.CreateVector<flatbuffers::Offset<TerrainRecord>>(*records) : 0);
}

struct HeroClassManager FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<HeroClass>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeroClass>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct HeroClassManagerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroClass>>> records) {
    fbb_.AddOffset(HeroClassManager::VT_RECORDS, records);
  }
  explicit HeroClassManagerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroClassManagerBuilder &operator=(const HeroClassManagerBuilder &);
  flatbuffers::Offset<HeroClassManager> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeroClassManager>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroClassManager> CreateHeroClassManager(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroClass>>> records = 0) {
  HeroClassManagerBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroClassManager> CreateHeroClassManagerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<HeroClass>> *records = nullptr) {
  return mengde::save::CreateHeroClassManager(
      _fbb,
      records ? _fbb.CreateVector<flatbuffers::Offset<HeroClass>>(*records) : 0);
}

struct HeroTemplateManager FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct HeroTemplateManagerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>>> records) {
    fbb_.AddOffset(HeroTemplateManager::VT_RECORDS, records);
  }
  explicit HeroTemplateManagerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroTemplateManagerBuilder &operator=(const HeroTemplateManagerBuilder &);
  flatbuffers::Offset<HeroTemplateManager> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeroTemplateManager>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroTemplateManager> CreateHeroTemplateManager(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HeroTemplate>>> records = 0) {
  HeroTemplateManagerBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroTemplateManager> CreateHeroTemplateManagerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<HeroTemplate>> *records = nullptr) {
  return mengde::save::CreateHeroTemplateManager(
      _fbb,
      records ? _fbb.CreateVector<flatbuffers::Offset<HeroTemplate>>(*records) : 0);
}

struct TerrainRecord FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TERRAIN = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const Terrain *terrain() const {
    return GetPointer<const Terrain *>(VT_TERRAIN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_TERRAIN) &&
           verifier.VerifyTable(terrain()) &&
           verifier.EndTable();
  }
};

struct TerrainRecordBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(TerrainRecord::VT_ID, id);
  }
  void add_terrain(flatbuffers::Offset<Terrain> terrain) {
    fbb_.AddOffset(TerrainRecord::VT_TERRAIN, terrain);
  }
  explicit TerrainRecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerrainRecordBuilder &operator=(const TerrainRecordBuilder &);
  flatbuffers::Offset<TerrainRecord> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TerrainRecord>(end);
    return o;
  }
};

inline flatbuffers::Offset<TerrainRecord> CreateTerrainRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<Terrain> terrain = 0) {
  TerrainRecordBuilder builder_(_fbb);
  builder_.add_terrain(terrain);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<TerrainRecord> CreateTerrainRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    flatbuffers::Offset<Terrain> terrain = 0) {
  return mengde::save::CreateTerrainRecord(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      terrain);
}

struct Terrain FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_MOVE_COSTS = 6,
    VT_CLASS_EFFECTS = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::Vector<int32_t> *move_costs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MOVE_COSTS);
  }
  const flatbuffers::Vector<int32_t> *class_effects() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLASS_EFFECTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_MOVE_COSTS) &&
           verifier.VerifyVector(move_costs()) &&
           VerifyOffset(verifier, VT_CLASS_EFFECTS) &&
           verifier.VerifyVector(class_effects()) &&
           verifier.EndTable();
  }
};

struct TerrainBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Terrain::VT_ID, id);
  }
  void add_move_costs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> move_costs) {
    fbb_.AddOffset(Terrain::VT_MOVE_COSTS, move_costs);
  }
  void add_class_effects(flatbuffers::Offset<flatbuffers::Vector<int32_t>> class_effects) {
    fbb_.AddOffset(Terrain::VT_CLASS_EFFECTS, class_effects);
  }
  explicit TerrainBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TerrainBuilder &operator=(const TerrainBuilder &);
  flatbuffers::Offset<Terrain> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Terrain>(end);
    return o;
  }
};

inline flatbuffers::Offset<Terrain> CreateTerrain(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> move_costs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> class_effects = 0) {
  TerrainBuilder builder_(_fbb);
  builder_.add_class_effects(class_effects);
  builder_.add_move_costs(move_costs);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Terrain> CreateTerrainDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const std::vector<int32_t> *move_costs = nullptr,
    const std::vector<int32_t> *class_effects = nullptr) {
  return mengde::save::CreateTerrain(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      move_costs ? _fbb.CreateVector<int32_t>(*move_costs) : 0,
      class_effects ? _fbb.CreateVector<int32_t>(*class_effects) : 0);
}

struct HeroTemplate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_HERO_CLASS = 6,
    VT_ATTR = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *hero_class() const {
    return GetPointer<const flatbuffers::String *>(VT_HERO_CLASS);
  }
  const Attribute *attr() const {
    return GetStruct<const Attribute *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_HERO_CLASS) &&
           verifier.VerifyString(hero_class()) &&
           VerifyField<Attribute>(verifier, VT_ATTR) &&
           verifier.EndTable();
  }
};

struct HeroTemplateBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(HeroTemplate::VT_ID, id);
  }
  void add_hero_class(flatbuffers::Offset<flatbuffers::String> hero_class) {
    fbb_.AddOffset(HeroTemplate::VT_HERO_CLASS, hero_class);
  }
  void add_attr(const Attribute *attr) {
    fbb_.AddStruct(HeroTemplate::VT_ATTR, attr);
  }
  explicit HeroTemplateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroTemplateBuilder &operator=(const HeroTemplateBuilder &);
  flatbuffers::Offset<HeroTemplate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeroTemplate>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroTemplate> CreateHeroTemplate(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> hero_class = 0,
    const Attribute *attr = 0) {
  HeroTemplateBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_hero_class(hero_class);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroTemplate> CreateHeroTemplateDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *hero_class = nullptr,
    const Attribute *attr = 0) {
  return mengde::save::CreateHeroTemplate(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      hero_class ? _fbb.CreateString(hero_class) : 0,
      attr);
}

struct HeroClass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_ATTR_GRADE = 6,
    VT_ATTACK_RANGE = 8,
    VT_MOVE = 10,
    VT_BI_HP = 12,
    VT_BI_MP = 14,
    VT_PROMOTION_INFO = 16
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const Attribute *attr_grade() const {
    return GetStruct<const Attribute *>(VT_ATTR_GRADE);
  }
  int32_t attack_range() const {
    return GetField<int32_t>(VT_ATTACK_RANGE, 0);
  }
  int32_t move() const {
    return GetField<int32_t>(VT_MOVE, 0);
  }
  const BaseIncr *bi_hp() const {
    return GetStruct<const BaseIncr *>(VT_BI_HP);
  }
  const BaseIncr *bi_mp() const {
    return GetStruct<const BaseIncr *>(VT_BI_MP);
  }
  const PromotionInfo *promotion_info() const {
    return GetPointer<const PromotionInfo *>(VT_PROMOTION_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<Attribute>(verifier, VT_ATTR_GRADE) &&
           VerifyField<int32_t>(verifier, VT_ATTACK_RANGE) &&
           VerifyField<int32_t>(verifier, VT_MOVE) &&
           VerifyField<BaseIncr>(verifier, VT_BI_HP) &&
           VerifyField<BaseIncr>(verifier, VT_BI_MP) &&
           VerifyOffset(verifier, VT_PROMOTION_INFO) &&
           verifier.VerifyTable(promotion_info()) &&
           verifier.EndTable();
  }
};

struct HeroClassBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(HeroClass::VT_ID, id);
  }
  void add_attr_grade(const Attribute *attr_grade) {
    fbb_.AddStruct(HeroClass::VT_ATTR_GRADE, attr_grade);
  }
  void add_attack_range(int32_t attack_range) {
    fbb_.AddElement<int32_t>(HeroClass::VT_ATTACK_RANGE, attack_range, 0);
  }
  void add_move(int32_t move) {
    fbb_.AddElement<int32_t>(HeroClass::VT_MOVE, move, 0);
  }
  void add_bi_hp(const BaseIncr *bi_hp) {
    fbb_.AddStruct(HeroClass::VT_BI_HP, bi_hp);
  }
  void add_bi_mp(const BaseIncr *bi_mp) {
    fbb_.AddStruct(HeroClass::VT_BI_MP, bi_mp);
  }
  void add_promotion_info(flatbuffers::Offset<PromotionInfo> promotion_info) {
    fbb_.AddOffset(HeroClass::VT_PROMOTION_INFO, promotion_info);
  }
  explicit HeroClassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeroClassBuilder &operator=(const HeroClassBuilder &);
  flatbuffers::Offset<HeroClass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HeroClass>(end);
    return o;
  }
};

inline flatbuffers::Offset<HeroClass> CreateHeroClass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    const Attribute *attr_grade = 0,
    int32_t attack_range = 0,
    int32_t move = 0,
    const BaseIncr *bi_hp = 0,
    const BaseIncr *bi_mp = 0,
    flatbuffers::Offset<PromotionInfo> promotion_info = 0) {
  HeroClassBuilder builder_(_fbb);
  builder_.add_promotion_info(promotion_info);
  builder_.add_bi_mp(bi_mp);
  builder_.add_bi_hp(bi_hp);
  builder_.add_move(move);
  builder_.add_attack_range(attack_range);
  builder_.add_attr_grade(attr_grade);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<HeroClass> CreateHeroClassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const Attribute *attr_grade = 0,
    int32_t attack_range = 0,
    int32_t move = 0,
    const BaseIncr *bi_hp = 0,
    const BaseIncr *bi_mp = 0,
    flatbuffers::Offset<PromotionInfo> promotion_info = 0) {
  return mengde::save::CreateHeroClass(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      attr_grade,
      attack_range,
      move,
      bi_hp,
      bi_mp,
      promotion_info);
}

struct PromotionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HERO_CLASS_ID = 4,
    VT_LEVEL = 6
  };
  const flatbuffers::String *hero_class_id() const {
    return GetPointer<const flatbuffers::String *>(VT_HERO_CLASS_ID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HERO_CLASS_ID) &&
           verifier.VerifyString(hero_class_id()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
};

struct PromotionInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hero_class_id(flatbuffers::Offset<flatbuffers::String> hero_class_id) {
    fbb_.AddOffset(PromotionInfo::VT_HERO_CLASS_ID, hero_class_id);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PromotionInfo::VT_LEVEL, level, 0);
  }
  explicit PromotionInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PromotionInfoBuilder &operator=(const PromotionInfoBuilder &);
  flatbuffers::Offset<PromotionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PromotionInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<PromotionInfo> CreatePromotionInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> hero_class_id = 0,
    int32_t level = 0) {
  PromotionInfoBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_hero_class_id(hero_class_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<PromotionInfo> CreatePromotionInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *hero_class_id = nullptr,
    int32_t level = 0) {
  return mengde::save::CreatePromotionInfo(
      _fbb,
      hero_class_id ? _fbb.CreateString(hero_class_id) : 0,
      level);
}

struct EquipmentManager FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RECORDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Equipment>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Equipment>> *>(VT_RECORDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           verifier.EndTable();
  }
};

struct EquipmentManagerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Equipment>>> records) {
    fbb_.AddOffset(EquipmentManager::VT_RECORDS, records);
  }
  explicit EquipmentManagerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentManagerBuilder &operator=(const EquipmentManagerBuilder &);
  flatbuffers::Offset<EquipmentManager> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EquipmentManager>(end);
    return o;
  }
};

inline flatbuffers::Offset<EquipmentManager> CreateEquipmentManager(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Equipment>>> records = 0) {
  EquipmentManagerBuilder builder_(_fbb);
  builder_.add_records(records);
  return builder_.Finish();
}

inline flatbuffers::Offset<EquipmentManager> CreateEquipmentManagerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Equipment>> *records = nullptr) {
  return mengde::save::CreateEquipmentManager(
      _fbb,
      records ? _fbb.CreateVector<flatbuffers::Offset<Equipment>>(*records) : 0);
}

struct Equipment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_VOLATILE_ATTRIBUTES = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const VolatileAttributes *volatile_attributes() const {
    return GetPointer<const VolatileAttributes *>(VT_VOLATILE_ATTRIBUTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_VOLATILE_ATTRIBUTES) &&
           verifier.VerifyTable(volatile_attributes()) &&
           verifier.EndTable();
  }
};

struct EquipmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Equipment::VT_ID, id);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(Equipment::VT_TYPE, type, 0);
  }
  void add_volatile_attributes(flatbuffers::Offset<VolatileAttributes> volatile_attributes) {
    fbb_.AddOffset(Equipment::VT_VOLATILE_ATTRIBUTES, volatile_attributes);
  }
  explicit EquipmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EquipmentBuilder &operator=(const EquipmentBuilder &);
  flatbuffers::Offset<Equipment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equipment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equipment> CreateEquipment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t type = 0,
    flatbuffers::Offset<VolatileAttributes> volatile_attributes = 0) {
  EquipmentBuilder builder_(_fbb);
  builder_.add_volatile_attributes(volatile_attributes);
  builder_.add_type(type);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<Equipment> CreateEquipmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t type = 0,
    flatbuffers::Offset<VolatileAttributes> volatile_attributes = 0) {
  return mengde::save::CreateEquipment(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      type,
      volatile_attributes);
}

struct VolatileAttributes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ATTRIBUTE_MODIFIER_LIST = 4,
    VT_EVENT_EFFECT_LIST = 6
  };
  const AttributeModifierList *attribute_modifier_list() const {
    return GetPointer<const AttributeModifierList *>(VT_ATTRIBUTE_MODIFIER_LIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EventEffect>> *event_effect_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EventEffect>> *>(VT_EVENT_EFFECT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTRIBUTE_MODIFIER_LIST) &&
           verifier.VerifyTable(attribute_modifier_list()) &&
           VerifyOffset(verifier, VT_EVENT_EFFECT_LIST) &&
           verifier.VerifyVector(event_effect_list()) &&
           verifier.VerifyVectorOfTables(event_effect_list()) &&
           verifier.EndTable();
  }
};

struct VolatileAttributesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attribute_modifier_list(flatbuffers::Offset<AttributeModifierList> attribute_modifier_list) {
    fbb_.AddOffset(VolatileAttributes::VT_ATTRIBUTE_MODIFIER_LIST, attribute_modifier_list);
  }
  void add_event_effect_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventEffect>>> event_effect_list) {
    fbb_.AddOffset(VolatileAttributes::VT_EVENT_EFFECT_LIST, event_effect_list);
  }
  explicit VolatileAttributesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VolatileAttributesBuilder &operator=(const VolatileAttributesBuilder &);
  flatbuffers::Offset<VolatileAttributes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VolatileAttributes>(end);
    return o;
  }
};

inline flatbuffers::Offset<VolatileAttributes> CreateVolatileAttributes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttributeModifierList> attribute_modifier_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EventEffect>>> event_effect_list = 0) {
  VolatileAttributesBuilder builder_(_fbb);
  builder_.add_event_effect_list(event_effect_list);
  builder_.add_attribute_modifier_list(attribute_modifier_list);
  return builder_.Finish();
}

inline flatbuffers::Offset<VolatileAttributes> CreateVolatileAttributesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AttributeModifierList> attribute_modifier_list = 0,
    const std::vector<flatbuffers::Offset<EventEffect>> *event_effect_list = nullptr) {
  return mengde::save::CreateVolatileAttributes(
      _fbb,
      attribute_modifier_list,
      event_effect_list ? _fbb.CreateVector<flatbuffers::Offset<EventEffect>>(*event_effect_list) : 0);
}

struct AttributeModifierList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENTRIES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>> *entries() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>> *>(VT_ENTRIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTRIES) &&
           verifier.VerifyVector(entries()) &&
           verifier.VerifyVectorOfTables(entries()) &&
           verifier.EndTable();
  }
};

struct AttributeModifierListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entries(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>>> entries) {
    fbb_.AddOffset(AttributeModifierList::VT_ENTRIES, entries);
  }
  explicit AttributeModifierListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeModifierListBuilder &operator=(const AttributeModifierListBuilder &);
  flatbuffers::Offset<AttributeModifierList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeModifierList>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeModifierList> CreateAttributeModifierList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AttributeModifier>>> entries = 0) {
  AttributeModifierListBuilder builder_(_fbb);
  builder_.add_entries(entries);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeModifierList> CreateAttributeModifierListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AttributeModifier>> *entries = nullptr) {
  return mengde::save::CreateAttributeModifierList(
      _fbb,
      entries ? _fbb.CreateVector<flatbuffers::Offset<AttributeModifier>>(*entries) : 0);
}

struct AttributeModifier FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_STAT_IDX = 6,
    VT_TURN = 8,
    VT_MOD = 10
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int16_t stat_idx() const {
    return GetField<int16_t>(VT_STAT_IDX, 0);
  }
  const TurnBased *turn() const {
    return GetStruct<const TurnBased *>(VT_TURN);
  }
  const StatMod *mod() const {
    return GetStruct<const StatMod *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int16_t>(verifier, VT_STAT_IDX) &&
           VerifyField<TurnBased>(verifier, VT_TURN) &&
           VerifyField<StatMod>(verifier, VT_MOD) &&
           verifier.EndTable();
  }
};

struct AttributeModifierBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(AttributeModifier::VT_ID, id);
  }
  void add_stat_idx(int16_t stat_idx) {
    fbb_.AddElement<int16_t>(AttributeModifier::VT_STAT_IDX, stat_idx, 0);
  }
  void add_turn(const TurnBased *turn) {
    fbb_.AddStruct(AttributeModifier::VT_TURN, turn);
  }
  void add_mod(const StatMod *mod) {
    fbb_.AddStruct(AttributeModifier::VT_MOD, mod);
  }
  explicit AttributeModifierBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttributeModifierBuilder &operator=(const AttributeModifierBuilder &);
  flatbuffers::Offset<AttributeModifier> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttributeModifier>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttributeModifier> CreateAttributeModifier(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int16_t stat_idx = 0,
    const TurnBased *turn = 0,
    const StatMod *mod = 0) {
  AttributeModifierBuilder builder_(_fbb);
  builder_.add_mod(mod);
  builder_.add_turn(turn);
  builder_.add_id(id);
  builder_.add_stat_idx(stat_idx);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttributeModifier> CreateAttributeModifierDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int16_t stat_idx = 0,
    const TurnBased *turn = 0,
    const StatMod *mod = 0) {
  return mengde::save::CreateAttributeModifier(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      stat_idx,
      turn,
      mod);
}

struct EventEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TURN = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  const TurnBased *turn() const {
    return GetStruct<const TurnBased *>(VT_TURN);
  }
  EventEffectImpl instance_type() const {
    return static_cast<EventEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const GeneralEventEffect *instance_as_GeneralEventEffect() const {
    return instance_type() == EventEffectImpl::GeneralEventEffect ? static_cast<const GeneralEventEffect *>(instance()) : nullptr;
  }
  const OnCmdEventEffect *instance_as_OnCmdEventEffect() const {
    return instance_type() == EventEffectImpl::OnCmdEventEffect ? static_cast<const OnCmdEventEffect *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TurnBased>(verifier, VT_TURN) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyEventEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GeneralEventEffect *EventEffect::instance_as<GeneralEventEffect>() const {
  return instance_as_GeneralEventEffect();
}

template<> inline const OnCmdEventEffect *EventEffect::instance_as<OnCmdEventEffect>() const {
  return instance_as_OnCmdEventEffect();
}

struct EventEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_turn(const TurnBased *turn) {
    fbb_.AddStruct(EventEffect::VT_TURN, turn);
  }
  void add_instance_type(EventEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(EventEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(EventEffect::VT_INSTANCE, instance);
  }
  explicit EventEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EventEffectBuilder &operator=(const EventEffectBuilder &);
  flatbuffers::Offset<EventEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EventEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<EventEffect> CreateEventEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TurnBased *turn = 0,
    EventEffectImpl instance_type = EventEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  EventEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_turn(turn);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct GeneralEventEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  GeneralEventEffectImpl instance_type() const {
    return static_cast<GeneralEventEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const GEERestoreHp *instance_as_GEERestoreHp() const {
    return instance_type() == GeneralEventEffectImpl::GEERestoreHp ? static_cast<const GEERestoreHp *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyGeneralEventEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const GEERestoreHp *GeneralEventEffect::instance_as<GEERestoreHp>() const {
  return instance_as_GEERestoreHp();
}

struct GeneralEventEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GeneralEventEffect::VT_TYPE, type, 0);
  }
  void add_instance_type(GeneralEventEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(GeneralEventEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(GeneralEventEffect::VT_INSTANCE, instance);
  }
  explicit GeneralEventEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeneralEventEffectBuilder &operator=(const GeneralEventEffectBuilder &);
  flatbuffers::Offset<GeneralEventEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeneralEventEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeneralEventEffect> CreateGeneralEventEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    GeneralEventEffectImpl instance_type = GeneralEventEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  GeneralEventEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_type(type);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct GEERestoreHp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MOD = 4
  };
  const StatMod *mod() const {
    return GetStruct<const StatMod *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<StatMod>(verifier, VT_MOD) &&
           verifier.EndTable();
  }
};

struct GEERestoreHpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mod(const StatMod *mod) {
    fbb_.AddStruct(GEERestoreHp::VT_MOD, mod);
  }
  explicit GEERestoreHpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GEERestoreHpBuilder &operator=(const GEERestoreHpBuilder &);
  flatbuffers::Offset<GEERestoreHp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GEERestoreHp>(end);
    return o;
  }
};

inline flatbuffers::Offset<GEERestoreHp> CreateGEERestoreHp(
    flatbuffers::FlatBufferBuilder &_fbb,
    const StatMod *mod = 0) {
  GEERestoreHpBuilder builder_(_fbb);
  builder_.add_mod(mod);
  return builder_.Finish();
}

struct OnCmdEventEffect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_INSTANCE_TYPE = 6,
    VT_INSTANCE = 8
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  OnCmdEventEffectImpl instance_type() const {
    return static_cast<OnCmdEventEffectImpl>(GetField<uint8_t>(VT_INSTANCE_TYPE, 0));
  }
  const void *instance() const {
    return GetPointer<const void *>(VT_INSTANCE);
  }
  template<typename T> const T *instance_as() const;
  const OCEEPreemptiveAttack *instance_as_OCEEPreemptiveAttack() const {
    return instance_type() == OnCmdEventEffectImpl::OCEEPreemptiveAttack ? static_cast<const OCEEPreemptiveAttack *>(instance()) : nullptr;
  }
  const OCEEEnhanceBasicAttack *instance_as_OCEEEnhanceBasicAttack() const {
    return instance_type() == OnCmdEventEffectImpl::OCEEEnhanceBasicAttack ? static_cast<const OCEEEnhanceBasicAttack *>(instance()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCE_TYPE) &&
           VerifyOffset(verifier, VT_INSTANCE) &&
           VerifyOnCmdEventEffectImpl(verifier, instance(), instance_type()) &&
           verifier.EndTable();
  }
};

template<> inline const OCEEPreemptiveAttack *OnCmdEventEffect::instance_as<OCEEPreemptiveAttack>() const {
  return instance_as_OCEEPreemptiveAttack();
}

template<> inline const OCEEEnhanceBasicAttack *OnCmdEventEffect::instance_as<OCEEEnhanceBasicAttack>() const {
  return instance_as_OCEEEnhanceBasicAttack();
}

struct OnCmdEventEffectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(OnCmdEventEffect::VT_TYPE, type, 0);
  }
  void add_instance_type(OnCmdEventEffectImpl instance_type) {
    fbb_.AddElement<uint8_t>(OnCmdEventEffect::VT_INSTANCE_TYPE, static_cast<uint8_t>(instance_type), 0);
  }
  void add_instance(flatbuffers::Offset<void> instance) {
    fbb_.AddOffset(OnCmdEventEffect::VT_INSTANCE, instance);
  }
  explicit OnCmdEventEffectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnCmdEventEffectBuilder &operator=(const OnCmdEventEffectBuilder &);
  flatbuffers::Offset<OnCmdEventEffect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnCmdEventEffect>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnCmdEventEffect> CreateOnCmdEventEffect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    OnCmdEventEffectImpl instance_type = OnCmdEventEffectImpl::NONE,
    flatbuffers::Offset<void> instance = 0) {
  OnCmdEventEffectBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_type(type);
  builder_.add_instance_type(instance_type);
  return builder_.Finish();
}

struct OCEEPreemptiveAttack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OCEEPreemptiveAttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OCEEPreemptiveAttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OCEEPreemptiveAttackBuilder &operator=(const OCEEPreemptiveAttackBuilder &);
  flatbuffers::Offset<OCEEPreemptiveAttack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OCEEPreemptiveAttack>(end);
    return o;
  }
};

inline flatbuffers::Offset<OCEEPreemptiveAttack> CreateOCEEPreemptiveAttack(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OCEEPreemptiveAttackBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OCEEEnhanceBasicAttack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MOD = 4
  };
  const StatMod *mod() const {
    return GetStruct<const StatMod *>(VT_MOD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<StatMod>(verifier, VT_MOD) &&
           verifier.EndTable();
  }
};

struct OCEEEnhanceBasicAttackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mod(const StatMod *mod) {
    fbb_.AddStruct(OCEEEnhanceBasicAttack::VT_MOD, mod);
  }
  explicit OCEEEnhanceBasicAttackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OCEEEnhanceBasicAttackBuilder &operator=(const OCEEEnhanceBasicAttackBuilder &);
  flatbuffers::Offset<OCEEEnhanceBasicAttack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OCEEEnhanceBasicAttack>(end);
    return o;
  }
};

inline flatbuffers::Offset<OCEEEnhanceBasicAttack> CreateOCEEEnhanceBasicAttack(
    flatbuffers::FlatBufferBuilder &_fbb,
    const StatMod *mod = 0) {
  OCEEEnhanceBasicAttackBuilder builder_(_fbb);
  builder_.add_mod(mod);
  return builder_.Finish();
}

inline bool VerifyEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, EventEffectImpl type) {
  switch (type) {
    case EventEffectImpl::NONE: {
      return true;
    }
    case EventEffectImpl::GeneralEventEffect: {
      auto ptr = reinterpret_cast<const GeneralEventEffect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case EventEffectImpl::OnCmdEventEffect: {
      auto ptr = reinterpret_cast<const OnCmdEventEffect *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEventEffectImpl(
        verifier,  values->Get(i), types->GetEnum<EventEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyGeneralEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, GeneralEventEffectImpl type) {
  switch (type) {
    case GeneralEventEffectImpl::NONE: {
      return true;
    }
    case GeneralEventEffectImpl::GEERestoreHp: {
      auto ptr = reinterpret_cast<const GEERestoreHp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyGeneralEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyGeneralEventEffectImpl(
        verifier,  values->Get(i), types->GetEnum<GeneralEventEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyOnCmdEventEffectImpl(flatbuffers::Verifier &verifier, const void *obj, OnCmdEventEffectImpl type) {
  switch (type) {
    case OnCmdEventEffectImpl::NONE: {
      return true;
    }
    case OnCmdEventEffectImpl::OCEEPreemptiveAttack: {
      auto ptr = reinterpret_cast<const OCEEPreemptiveAttack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OnCmdEventEffectImpl::OCEEEnhanceBasicAttack: {
      auto ptr = reinterpret_cast<const OCEEEnhanceBasicAttack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyOnCmdEventEffectImplVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOnCmdEventEffectImpl(
        verifier,  values->Get(i), types->GetEnum<OnCmdEventEffectImpl>(i))) {
      return false;
    }
  }
  return true;
}

inline const mengde::save::Scenario *GetScenario(const void *buf) {
  return flatbuffers::GetRoot<mengde::save::Scenario>(buf);
}

inline const mengde::save::Scenario *GetSizePrefixedScenario(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mengde::save::Scenario>(buf);
}

inline bool VerifyScenarioBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mengde::save::Scenario>(nullptr);
}

inline bool VerifySizePrefixedScenarioBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mengde::save::Scenario>(nullptr);
}

inline void FinishScenarioBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mengde::save::Scenario> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedScenarioBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mengde::save::Scenario> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace save
}  // namespace mengde

#endif  // FLATBUFFERS_GENERATED_SCENARIO_MENGDE_SAVE_H_
